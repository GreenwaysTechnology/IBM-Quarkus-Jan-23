         	  Microservice-HTTP Based Microserivce
  	 	  RESTFull Web Service using Jax-rs Spec
		      using RESTEasy Framework
.....................................................................................
RESTEasy:
  RESTEasy is a JBoss / Red Hat project that provides various frameworks to help you build RESTful Web Services and RESTful Java applications. It is an implementation of the Jakarta RESTful Web Services, an Eclipse Foundation specification that provides a Java API for RESTful Web Services over the HTTP protocol.

Moreover, RESTEasy also implements the MicroProfile REST Client specification API

Quarkus team uses RESTEasy framework for building MicroService's REST API Design.

Traditional RESTEasy apps are deployed on "Jboss,Apach Tomcat" like web containers.

Quarkus RestEasy implementation apps are not deployed on traditional web containers,
Quarkus uses "VertX Engine which intern uses Netty Container" -  Non Blocking Servers.

Quarkus apps are non blocking and async  in nature
..................................................................................
				 Non Blocking and Async
...................................................................................

Why non blocking? What is advantages?

=> To reduce Systems Resources(Main Memory , CPU)

.....................................................................................
		 Blocking and Non blocking IO - Network Programming
...................................................................................
Web Servers:

C10k:
  How improve web server to handle more no of connections with limited resources.

Quarkus is sitting on Vertx engine, Vertx sits on Netty Engine, Netty at core uses NIO , NIO uses os "epoll or kqueue or IOCP" Of os wrappers.

Vertx Takes of care thread Managment?
  Vertx provides per cpu 2 threads

if you have 12 core cpu=> 12*2=24 Threads => Event loop threads...

.....................................................................................
			Quarkus apps enable NonBlocking arch by default....
.....................................................................................
			 Reactive Programming + Non Blockig
....................................................................................
What is Reactive Programming?

 It is programming model which has been on the top of various industry standard design patterns and pricinciples to optimize the building distributed apps(micro service)

Why Reactive Programming?

1. It must react to its users (responsive).
2. It must react to failure and stay available (resilient).
3. It must react to variable load conditions (elastic).
4. It must react to inputs (message-driven).

Reactive Programming and its design patterns  and principles?

1.NonBlocking Arch , Async
2.Observer pattern 
     -Core design pattern for building event driven arch
 Publisher publishes events  - data,error,complete
 Subscriber subscribe events - success,error,complete
3.iterator pattern
   Pull data - tradtional iterator
   Reactive Pull - Push
4.functional programming style : from imperative to declarative
   -hof - higher order function
   -pure function and immutablity = declarative, programming  - concurrency

Resources:
https://reactivex.io/intro.html
...................................................................................
		....................................................................................  
		     Standards of Reactive Programming
....................................................................................

Standards define how to build efficient distributed system using reactive principles
https://www.reactivemanifesto.org/

Reactive Streams
   It is built for java.
   Provides spec and apis how to handle back pressure in non blocking message work    flows.
   It is common/unified api for many implementators
https://www.reactive-streams.org/
,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,

Reactive Programming implemenation:
...................................

Reactive programming concepts are language independent.

Java Implmentation:
...................
1.Rxjava
2.Project Reactor -  used by Spring Framework by default.
3.SmallRye Muntiny - Red hat...


Mutiny was built by Red hat team
Mutiny first integrated with Quarkus, later with Vertx.
Mutiny is reactive stream certified
Mutiny is the perfect companion to tame the async nature of apps with non blocking io.
....................................................................................

Reactive Implementation:

Steps: 

1.Create standalone Mutiny java maven project

....................................................................................
			 Core Concepts of Muntiny
....................................................................................

Publisher:
  Object - Provider of data 
  Who publish events
Subscriber:
  Object - Receiver of data
  Who listens for events
Subscription -
   Object who conects Publisher and Subscriber in back end.
Operators 
   Are apis provided to process "stream of data"


Events:
 1.onItem -  onData - -> data event published by publisher when ever the data is available
2.onFailure - onError - error event published by publisher when ever the error occurred.
3.onComplete -  No more data /error published by publisher...


Muntiny Publishers Types:

1.Uni 
  Emit o or 1 item
2.Multi 
   1..to Many items - Stream

Steps:
1.create Publisher
2.emits data or error events
3.subscribe for data or error events.

Data processing 
1.create Publisher
2.emits data or error events
3.Process events(data)
4.subscribe for data or error events.


How to emit data?
import io.smallrye.mutiny.Uni;
import io.smallrye.mutiny.groups.UniSubscribe;

public class HelloMutinyUni {
    public static void main(String[] args) {
        //create publisher
        /**
         * Uni is interface
         * createFrom is factory api to create Uni implementation Object
         * item is method(operator) , to emit event called "onitem"
         * subcribe method will return "Subscriber Object"
         */
//        UniSubscribe<String> hello = Uni.createFrom().item("Hello").subscribe();
//        //listen for events
//        hello.with(s -> System.out.println(s),err->System.out.println(err));
//        
        Uni.createFrom().item("Hello").subscribe().with(s -> System.out.println(s),err->System.out.println(err));
    }
}

How to throw error? How to handle it?

import io.smallrye.mutiny.Uni;

public class ErrorMuntinyUni {
    public static void main(String[] args) {
        Uni.createFrom()
               .failure(new RuntimeException("something went wrong"))
                .subscribe().with(System.out::println,System.out::println);
    }
}
................................................................................
			 Reactive Programming enables data pipe lines
...................................................................................

How do you process data?

Ways

1.inside database you can process using sql query
2.Inside application you can process data using imerative logic

Reactive programming helps to process data in non blocking,async ways using declarative pattern.

 Source(Where data is emitted)------PL1-------PL2------PL3----------------|subscriber

Pipe lines are operators(methods)
.................................

import io.smallrye.mutiny.Uni;

import java.time.Duration;

public class MuntinyUniPipeLine {
    public static void main(String[] args) {

        System.out.println("Start");
        Uni.createFrom()
                .item("hello")
                //data pipe lines
                .onItem().transform(item-> {
                    return item.toUpperCase();
                })
                //delay; subscribe after some time
                .onItem().delayIt().by(Duration.ofMillis(100))
                .subscribe().with(i->System.out.println(i));
        System.out.println("end");

    }

}
....................................................................................
			Exception Handling/Failures in Reactive 
....................................................................................

There are two ways you can react to the failures

1.throw exception and handle it
2.throw exception and convert into postive message :Recovery

import io.smallrye.mutiny.Uni;

public class ErrorHandlingUni {
    public static void main(String[] args) {
//        Uni.createFrom()
//                .failure(new RuntimeException("something went wrong"))
//                .subscribe().with(System.out::println,System.out::println);
        Object fallback;
        Uni.createFrom()
                .failure(new RuntimeException("something went wrong"))
                .onFailure()
                .recoverWithItem("Fallback Response")
                .onItem().transform(item->item.toString().toUpperCase())
                .subscribe().with(System.out::println);
    }
}
...................................................................................
			Multi - more no of data you want stream,process,emits
.................................................................................


import io.smallrye.mutiny.Multi;

public class MultiStream {
    public static void main(String[] args) {
        Multi.createFrom()
                .items(1,2,3,4,5,6,7,8,9,10)
                .subscribe()
                .with(item->System.out.println(item));
    }
}
.....................................................................................
Data Processing in Reactive
import io.smallrye.mutiny.Multi;

public class MultiProcessing {
    public static void main(String[] args) {
        Multi.createFrom()
                .items(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
                .onItem().transform(i -> i * 2) //double it
                .select().first(3) // get first 3 items
                .filter(item -> item < 5) //filter item less than 5
                .subscribe()
                .with(item -> System.out.println(item));

    }
}
.....................................................................................
JAX RS- RestEasy and Reactive:

Quarkus has enbled two libs for RestEasy

Reactive Version
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-resteasy-reactive</artifactId>
    </dependency>

Non Reactive Version
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-resteasy</artifactId>
    </dependency>

Recommendation is Reactive version, so that our app is enabled with non blocking...






















			